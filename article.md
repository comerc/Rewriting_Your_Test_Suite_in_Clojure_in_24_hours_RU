#Переписываем сценарии тестирования на Clojure за 24 часа

Эта история о том, как я написал компилятор для автоматической трансляции сценариев тестирования [CircleCI](https://circleci.com/), состоящих из 14000 строк, в другую библиотеку тестирования за 24 часа.

На сегодняшний день набор тестов [CircleCI](https://circleci.com/) возможно один из самых больших в мире Clojure. Наш серверный код на 100% Clojure, включая тесты, состоящие из 14000 строк, в 140 файлах, с 5000 ассертами. Без [распараллеливания](https://circleci.com/docs/how-parallelism-works/) выполнение занимает 40 минут.

На старте этого приключения все тесты были написаны на [Midje](https://github.com/marick/Midje) - библиотека для BDD тестирования, что-то похожее на RSpec. Мы не были особо счастливы с Midje, и решили перейти на [clojure.test](http://richhickey.github.io/clojure/clojure.test-api.html), которая, возможно, самая широко используемая библиотека для тестирования. `clojure.test` проще и в ней меньше магии, больше экосистема инструментов и плагинов.

Очевидно, что не практично переписывать 5000 тестов руками. Вместо этого мы решили использовать Clojure, чтобы переписать их автоматически, используя встроенные в Clojure функции манипулирования языком.

Clojure является гомоиконным - это значит, что все исходные файлы могут быть представлены в виде структуры данных. Наш транслятор переводит каждый тестовый файл в структуру данных Clojure. Затем мы преобразуем код, перед тем, как записать его обратно на диск. Как только он записан, мы можем запустить тесты, и даже автоматически добавить файл обратно в систему контроля версий, если тесты прошли, и все это не выходя из REPL.

##Чтение

Ключем ко всей этой операции является `read`. `read-string` втроенная в Clojure функция, которая принимает строку, содержащую любой Clojure код, и возвращает его, как структуру данных Clojure. Эту же самую функцию использует компилятор, когда загружает исходные файлы. Пример: `(read-string "[1 2 3]")` вернет `[1 2 3]`.

Мы используем `read` для превращения кода наших тестов в большой вложенный лист, который может быть изменен обычным кодом Clojure.

##Преобразование

Наши тесты были написаны с использованием `midje`, и мы хотим преобразовать их для использования с `clojure.test`. Пример теста использующего `midje`:

```
(ns circle.foo-test
  (:require [midje.sweet :refer :all]
            [circle.foo :as foo]))
(fact "foo works"
  (foo x) => 42)
```  

и преобразованная версия, использующая `clojure.test`:

```
(ns circle.foo-test
  (:require [clojure.test :refer :all]))

(deftest foo-works
  (is (= 42 (foo x))))
```

Преобразование включает замену:

- `midje.sweet` на `clojure.test` в ns форме

- `(fact "a test name"...)` на `(deftest a-test-name ...)`, потому что имена `clojure.test` переменные, а не строки

- `(foo x) => 42` на `(is (= 42 (foo x)))`

- мелкие детали, которые пока пропустим

Преобразование - это простой обход дерева в глубину:

```
(defn munge-form [form]
  (let [form (-> form
                 (replace-midje-sweet)
                 (replace-foo)
                 ...)]
    (cond
      (or (list? form)
          (vector? form)) (-> form
                              (replace-fact)
                              (replace-arrow)
                              (replace-bar)
                              ...
                              (map munge-form)))
      :else form))
```

Поведение `->` похоже на chaining в Ruby или JQuery, или как Bash’s pipes: передает результат вычисления вызова функции, как аргумент, в вызов следующей функции.

Первая часть `(let [form ...])` берёт форму Clojure и вызывает в ней каждую функцию преобразования. Вторая часть берет список из представленных в виде форм остальных Clojure выражений и функций – и также рекурсивно преобразует их.

Интересный процесс происходит в функциях замены. Они все в основном формы:

```
(if (this-form-is-relevant? form)
  (some-transformation form)
  form)
```

т.е., они проверяют является ли переданная форма релевантной, и если так, преобразует их нужным образом. Поэтому `replace-midje-sweet` выглядит как:

```
(defn replace-midje-sweet [form]
  (if (= 'midje.sweet form)
    'clojure.test
    form))
```

##Стрелки

Основное поведение тестирования в Midje сосредотачивается на “стрелках” - идеоматическая конструкция, которую Midje использует для имплементации декларативных тест кейсов BDD стиля. Простой пример:

```
(foo 42) => 5
```

утверждает что `(foo 42)` возвращает 5.

В зависимости от того, какие стрелки используются, и какие типы по другую сторону от стрелки, варьируется большое количество разных поведений.

```
(foo 42) => map?
```

Если выше в примере справа это функция, то утверждается что результат правдив когда передан в функцию map?. В Clojure это было бы так:

```
(map? (foo 42))
```

Несколько примеров midje стрелок:

```
(foo 42) => falsey
(foo 42) => map?
(foo 42) => (throws Exception)
(foo 42) =not=> 3
(foo 42) => #"hello world" ;; regex
(foo 42) =not=> "hello"
```

####Замена стрелок

Данное преобразование обрабатывается порядка сорока [core.match](https://github.com/clojure/core.match) правилами, которые выглядят вот так:

```
(match [actual arrow expected]
  [actual '=> 'truthy] `(is ~actual)
  [actual '=> expected] `(is (= ~expected ~actual)
  [actual '=> (_ :guard regex?)] `(is (re-find ~contents ~actual))
  [actual '=> nil] `(is (nil? ~actual)))
```

(Для экспертов Clojure: чтобы повысить читаемость я игнорировал большинство символов ~’ в макросе выше. Чтобы посмотреть как реально это выглядит, смотрите исходные файлы.)

Большинство преобразований простые. Однако, всё становится гораздо сложение с формой `contains`:

```
(foo 42) => (contains {:a 1})
(foo 42) => (contains [:a :b] :gaps-ok)
(foo 42) => (contains [:a :b] :in-any-order)
(foo 42) => (contains "hello")
```

Пследний кейс особенно интересный. В выражении

```
(foo 42) => (contains "hello")
```

есть два совершенно разных значения, при которых тест будет успешно пройден. `(foo 42)` может быть списком, который содержит айтем “hello”, или может быть строкой, которая содержит подстроку “hello”:

```
"hello world" => (contains "hello")
["foo" "hello" "bar"] => (contains "hello")
```

В общем, форма `contains` сложна для автоматического преобразования. Некоторые кейсы требуют дополнительной информации во время выполнения (как последний пример), и т.к. не существует реализации для большинства кейсов `contains` в языке Clojure, таких как `(contains [:a :b] :in-any-order)`, мы решили положить на все кейсы `contains`. Правило “потерпеть неудачу” выглядит так:

```
[actual arrow expected] (is (~arrow ~expected ~actual))
```

которое превращает `(foo 42) => (contains bar)` в `(is (=> (contains bar) (foo 42)))`. Оно преднамеренно не компилируется, потому как определение функции стрелки midje не загружено, и мы можем поправить это руками.

####Информация о типах во время выполнения

Была еще одна дополнительная компиляция с автоматическим преобразованием. Если имеем два выражения:

```
(let [bar 3]
  (foo) => bar
```

и

```
(let [bar clojure.core/map?]
  (foo) => bar
```

стрелка midje зависит от выражения справа, которое может быть определено только (легко) во время выполнения. Если `bar` резолвится в данные, как string, number, list или map, midje проверяет на равенство. Но если `bar` резолвится в функцию, midje _вызывает_ эту функцию, т.е. `(is (= bar (foo)))` против `(is (bar (foo)))`. 90% нашего решения требует (`require`) исходного пространства имен тестов, и резолвит (`resolve`) функции во время процесса преобразования:

```
(defn form-is-fn? [ns f]
  (let [resolved (ns-resolve ns f)]
    (and resolved (or (fn? resolved)
                      (and (var? resolved)
                           (fn? @resolved)))))))
```

В большинстве случаев это работает отлично, но проблема возникает, когда локальная переменная перекрывает глобальную:

```
(let [s [1 2 3]
      count (count s)]
  (foo s) => count)
```

В этом случае мы хотим `(is (= count (foo s)))`, но получаем `(is (count (foo s)))`, что ошибочно, т.к. в локальном окружении `count` - это число, и `(3 [1 2 3])` вызывает ошибку. К счастью, таких ситуаций было мало, решение этой проблемы потребовало бы написания полноценного компилятора с определением локальных переменных в окружении.

##Выполнение тестов

Когда преобразование кода было написано, нам нужно было понять работает ли оно. Т.к. мы запускаем код в REPL во время выполнения, нужно (после преобразования) просто запускать тесты встроенной функцией `clojure.test`.

Решения `clojure.test` помогают связать вместе процессы преобразования и вычисления. Все тестовые функции могут быть вызваны из REPL, и даже `(clojure.test/run-all-tests)` возвращает читаемое значение, отображение (`map`), содержащее количество тестов, пройденных и упавших:

```
{:pass 61, :test 21, :error 0, :fail 0}
```

Возможность запускать тесты в REPL делает процесс очень удобным, можно делать изменения в компиляторе и перетестировать, тут же получая обратную связь.

####Чтение

Однако, не все работало так просто.

“reader” (выражение в Clojure для обозначения части компилятора, которая имплементирует функцию `read`) спроектирован для преобразования исходных файлов в структуры данных, прежде всего для использования компилятором. Он убирает комментарии, раскрывает макросы, что требует от нас проверки всех diff-ов вручную, чтобы вернуть эти строки. К счастью в тестах их было всего несколько. В нашем стиле программирования мы как правило предпочитаем документирование комментариям, и изолируем макросы в небольшом количестве файлов, так что это нас не сильно затронуло.

####Отступы

Мы не нашли хорошую библиотеку, которая бы сделала изящные отступы в нашем новом коде. Мы использовали `clojure.pprint`, которая возможно и является лучшей библиотекой, не делает чего-то сверхествественного. Мы не считали необходимым писать такую библиотеку в рамках этого проекта, так что некоторые файлы были записаны обратно на диск с не очень красивыми пробелами и отступами. Теперь, когда мы работаем непосредственно с файлом, мы можем исправить это руками. Реально это потребовало бы инструмента, который понимает идиоматическое форматирование и учитывает метаданные файла и строк на этапе чтения данных.

Была большая задержка между переписыванием сценариев и публикацией этой статьи. Тем временем состоялся релиз [rewrite-clj](https://github.com/xsc/rewrite-clj). Я не пользовался ей, но на первый взгляд в ней есть то, чего нам так не хватало.

##Результаты

Около 40% тестов были пройдены без нашего вмешательства, что на самом деле потрясающе, учитывая насколько быстро мы собрали это решение. В оставшихся файлах около 90% тест-ассертов были преобразованы и пройдены. Так что 94% ассертов во всех файлах могут быть преобразованы автоматически - великолепный результат.

Наш код можно найти на GitHub [здесь](https://github.com/circleci/translate-midje). Дайте [нам](https://twitter.com/arohner) знать, если будете использовать его. Т.к. мы бы не рекомендовали его для неконтроллируемого преобразования, особенно из-за комментариев и макросов, это работает хорошо для [CircleCI](https://circleci.com/) как часть контроллируемого процесса.
